//GPU计算地形生成
#pragma kernel BuildLODMap
#pragma kernel BuildPatches
#pragma kernel TraverseQuadTree

//keywords(定义成本地关键字 __ 防止禁用时出问题)


#include "./CommonInput.hlsl"

Texture2D<float4> MinMaxHeightTexture;
Texture2D<float4> _HeightMap;
RWTexture2D<float4> _LodMap;

//起初，所有节点都存放在ConsumeNodeList中
ConsumeStructuredBuffer<uint2> ConsumeNodeList;
//若分割，分割后的4个节点放入AppendNodeList
AppendStructuredBuffer<uint2> AppendNodeList;
//否则就不作处理，将node坐标与其LOD值放入AppendFinal
AppendStructuredBuffer<uint3> AppendFinalNodeList;
//最后四叉树遍历完之后，存放最终筛选的合适节点
StructuredBuffer<uint3> FinalNodeList;
//保存Node的一些信息，通过NodeID访问
RWStructuredBuffer<NodeDescriptor> NodeDescriptors;
//Traverse QuadTree Kernal 执行的LOD级别
uniform uint PassLOD;
uniform float3 _CameraPositionWS;
//世界尺寸大小
uniform float3 WorldSize;
uniform int _BoundsHeightRedundance;
//节点评价系数，决定是否对其进行细分（x分量是距离系数）
uniform float4 NodeEvaluation;
/**
 *WorldLodParams
记录了每个Lod级别的(nodeSize,patchExtent,nodeCount,sectorCountPerNode)
其中:
- nodeSize为Node的边长(米)
- patchExtent是一个patch的半边长（一个Node有8x8个patch）
- nodeCount等于WorldSize/nodeSize
- sectorCountPerNode等于2^lod
保存在一个float4变量中
**/
//存放从CPU中收到的平面数据
uniform float4 _CameraFrustumPlanes[6];
uniform float4 WorldLodParams[6];
uniform uint NodeIDOffsetOfLOD[6];
//调试用buffer
AppendStructuredBuffer<float2> EvaluateDebug;
AppendStructuredBuffer<float3> NodePositionDebug;
AppendStructuredBuffer<Bounds> BoundsOutputDebug;
AppendStructuredBuffer<float> IfCullEnabled;
//裁剪缓存区
AppendStructuredBuffer<RenderPatch> CulledPatchList;

//Node节点处理(世界平面被割为25块，每一块区域都视作一个Node)

AppendStructuredBuffer<BoundsDebug> BoundsList;



float GetNodeSize(uint lod){
    return WorldLodParams[lod].x;
}
//节点个数
float GetNodeCount(uint lod){
    return WorldLodParams[lod].z;
}
//
float GetPatchExtent(uint lod){
    return WorldLodParams[lod].y;
}

uint GetSectorCountPerNode(uint lod){
    return (uint)WorldLodParams[lod].w;
}

float2 GetNodePositionWS2(uint2 nodeLoc,uint mip){
    float nodeMeterSize = GetNodeSize(mip);
    float nodeCount = GetNodeCount(mip);
    float2 nodePositionWS = ((float2)nodeLoc - (nodeCount-1)*0.5) * nodeMeterSize;
    return nodePositionWS;
}

//得到节点的世界空间坐标
float3 GetNodePositionWS(uint2 nodeLoc,uint lod){
    float2 nodePositionWS = GetNodePositionWS2(nodeLoc,lod);
    //带上高度图之后，需要求得每个节点的最小高度和最大高度，用于构建包围盒
    //从最高分辨率160x160一直到5x5
    float2 minMaxHeight = MinMaxHeightTexture.mips[lod+3][nodeLoc].xy;
    float y = (minMaxHeight.x + minMaxHeight.y) * 0.5 * WorldSize.y;
    return float3(nodePositionWS.x,y,nodePositionWS.y);
}

//节点评估
bool EvaluateNode(uint2 nodeLoc,uint lod){
    float3 positionWS = GetNodePositionWS(nodeLoc,lod);
    NodePositionDebug.Append(positionWS);
    //计算世界空间中摄像机和节点位置的距离
    float dis = distance(_CameraPositionWS,positionWS);
    float nodeSize = GetNodeSize(lod);
    //节点评估算法,dis是节点中心到摄像机距离，nodeSize是节点边长，c是用户控制系数
    float f = dis / (nodeSize * NodeEvaluation.x);    
    if( f < 1){
        return true;
    }
    return false;
}


//NodeID
uint GetNodeId(uint3 nodeLoc){
    return NodeIDOffsetOfLOD[nodeLoc.z] + nodeLoc.y * GetNodeCount(nodeLoc.z) + nodeLoc.x;
}
//NodeID,xy存储node的location，z存储mip值
uint GetNodeId(uint2 nodeLoc,uint mip){
    return GetNodeId(uint3(nodeLoc,mip));
}

[numthreads(1,1,1)]
void TraverseQuadTree (uint3 id : SV_DispatchThreadID)
{
    uint2 nodeLoc=ConsumeNodeList.Consume();
    //节点ID:对应LOD层级和nodeLoc
    uint nodeId = GetNodeId(nodeLoc,PassLOD);
    NodeDescriptor desc = NodeDescriptors[nodeId];
    if(PassLOD > 0 && EvaluateNode(nodeLoc,PassLOD)){
        //四叉树分割
        //分割过的子节点 放入AppendNodeList(虽然算法暂未知)
        AppendNodeList.Append(nodeLoc * 2 + uint2(0,0));
        AppendNodeList.Append(nodeLoc * 2 + uint2(1,0));
        AppendNodeList.Append(nodeLoc * 2 + uint2(0,1));
        AppendNodeList.Append(nodeLoc * 2 + uint2(1,1));
        desc.branch = 1;
    }else{
        AppendFinalNodeList.Append(uint3(nodeLoc,PassLOD));
        desc.branch = 0;
    }
    NodeDescriptors[nodeId] = desc;
}

//*********裁剪部分************//

bool IsOutSidePlane(float4 plane,float3 position)
{
    return dot(plane.xyz,position) + plane.w < 0;
}
//AABB包围盒,对每个点检测是否在视锥体外
bool IsAABBOutSidePlane(float4 plane,float3 boundsMin,float3 boundsMax)
{
    //包围盒的八个点分别进行判断
    return  IsOutSidePlane(plane,boundsMin)&&
        IsOutSidePlane(plane,boundsMax)&&
        IsOutSidePlane(plane,float3(boundsMin.x,boundsMin.y,boundsMax.z))&&
        IsOutSidePlane(plane,float3(boundsMin.x,boundsMax.y,boundsMin.z))&&
        IsOutSidePlane(plane,float3(boundsMin.x,boundsMax.y,boundsMax.z))&&
        IsOutSidePlane(plane,float3(boundsMax.x,boundsMin.y,boundsMax.z))&&
        IsOutSidePlane(plane,float3(boundsMax.x,boundsMax.y,boundsMin.z))&&
        IsOutSidePlane(plane,float3(boundsMax.x,boundsMin.y,boundsMin.z));
}

Bounds GetPatchBounds(RenderPatch patch)
{
    //构建bound包围盒
    float halfSize=GetPatchExtent(patch.lod);
    Bounds bounds;
    float3 boundsMin,boundsMax;
    boundsMin.xz=patch.position - halfSize;
    boundsMax.xz=patch.position + halfSize;
    boundsMin.y=patch.minMaxHeight.x;
    boundsMax.y=patch.minMaxHeight.y;
    bounds.minPosition=boundsMin;
    bounds.maxPosition=boundsMax;
    return bounds;
}

bool IsBoundsOutSidePlane(float4 plane,Bounds bounds)
{
    return IsAABBOutSidePlane(plane,bounds.minPosition,bounds.maxPosition);
}
//视锥裁剪
bool FrustumCull(float4 planes[6],Bounds bounds)
{
    //6个平面对包围盒进行判断
    return IsBoundsOutSidePlane(planes[0],bounds)||
        IsBoundsOutSidePlane(planes[1],bounds)||
        IsBoundsOutSidePlane(planes[2],bounds)||
        IsBoundsOutSidePlane(planes[3],bounds)||
        IsBoundsOutSidePlane(planes[4],bounds)||
        IsBoundsOutSidePlane(planes[5],bounds);        
}
//IfCullEnabled用于检测裁剪是否正确
//如开启 就输出1
//未开启 就输出0
bool Cull(Bounds bounds)
{

    if(FrustumCull(_CameraFrustumPlanes,bounds))
    {
        IfCullEnabled.Append(float(1.0f));
        return true;
    }
    IfCullEnabled.Append(float(0.0f));
   return false; 
}

RenderPatch CreatePatch(uint3 nodeLoc,uint2 patchOffset){
    uint lod = nodeLoc.z;
    float nodeMeterSize = GetNodeSize(lod);
    float patchMeterSize = nodeMeterSize / PATCH_COUNT_PER_NODE;
    float2 nodePositionWS = GetNodePositionWS2(nodeLoc.xy,lod);
    uint2 patchLoc = nodeLoc.xy * PATCH_COUNT_PER_NODE + patchOffset;
    //这里minmaxHeight要注意，从分辨率高的图从上往下采样(1280x1280的图开始)
    //否则会造成高度丢失,在生成patch包围盒的时候会出问题
    float2 minMaxHeight = MinMaxHeightTexture.mips[lod][patchLoc].rg * WorldSize.y + float2(-_BoundsHeightRedundance,_BoundsHeightRedundance);
    RenderPatch patch;
    patch.lod = lod;
    patch.position = nodePositionWS + (patchOffset - (PATCH_COUNT_PER_NODE - 1) * 0.5) * patchMeterSize;
    patch.minMaxHeight = minMaxHeight;
    patch.lodTrans = 0;
    return patch;
}

uint GetLod(uint2 sectorLoc)
{
    if(sectorLoc.x<0||sectorLoc.y<0||sectorLoc.x>=SECTOR_COUNT_WORLD||sectorLoc.y>=SECTOR_COUNT_WORLD)
    {
        return 0;
    }
    return round(_LodMap[sectorLoc].r*MAX_TERRAIN_LOD);
}


//精度增加：随着LOD层级降低，MinMax贴图精度应该更高
//核心算法
//遍历四叉树，进行节点评价，生成AppendFinalNodeList和NodeDescriptors

//LOD 0层级的Node，边长64x64m
//LOD 0层级的patch，边长8x8米 =>一个Node有8x8个patch
//每一个线程都对应一个patch，一共要起64个
//对于更高层级的LOD Node，按比例放大patch即可
//根据文档 是用于修理因Patch被放大导致的拼缝
[numthreads(8,8,1)]
void BuildLODMap(uint3 id:SV_DispatchThreadID)
{
    uint2 sectorLoc=id.xy;
    [unroll]
    for(uint lod=MAX_TERRAIN_LOD;lod>=0;lod--)
    {
        uint sectorCount=GetSectorCountPerNode(lod);
        uint2 nodeLoc=sectorLoc/sectorCount;
        uint nodeId=GetNodeId(nodeLoc,lod);
        NodeDescriptor desc=NodeDescriptors[nodeId];
        if(desc.branch==0)
        {
            _LodMap[sectorLoc]=lod*1.0/MAX_TERRAIN_LOD;
            return;
        }
    }
}

[numthreads(8,8,1)]
void BuildPatches(uint3 id:SV_DispatchThreadID,uint3 groupId:SV_GroupID,uint3 groupThreadID:SV_GroupThreadID)
{
    uint3 nodeLoc=FinalNodeList[groupId.x];
    uint2 patchOffset=groupThreadID.xy;    
    //生成Patch
    RenderPatch patch=CreatePatch(nodeLoc,patchOffset);
    EvaluateDebug.Append(patch.minMaxHeight);
    Bounds bounds=GetPatchBounds(patch);
    //Debug输出bounds位置
    BoundsOutputDebug.Append(bounds);
    if(Cull(bounds))
    {
        return;
    }
    CulledPatchList.Append(patch); 
}


